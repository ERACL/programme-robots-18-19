#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorSONAR)
#pragma config(Sensor, S3,     redButton,      sensorTouch)
#pragma config(Sensor, S4,     ,               sensorSONAR)
#pragma config(Motor,  mtr_Matrix_S1_1, motorD,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_2, motorE,        tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_3, motorRight,    tmotorMatrix, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_4, motorLeft,     tmotorMatrix, openLoop)
#pragma config(Servo,  srvo_Matrix_S1_1, servo1,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, servo3,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Lorsque la balance est du coté gauche
#define sensorFront S2
#define sensorFront2 S4
//#define sensorBack S4

#include "config.c"
#include "position.c"
#include "movement.c"
#include "sonar.c"

task displayPos() {
	struct PosData pos;
	while (true) {
		wait1Msec(200);
		getPosition(&pos);
		displayTextLine(1, "X %5.1f", pos.x);
		displayTextLine(3, "Y %5.1f", pos.y);
		displayTextLine(5, "O %5.1f", pos.orientation);
		//writeDebugStreamLine("X:%5.1f Y:%5.1f O:%5.1f", pos.x, pos.y, pos.orientation);
	}
}

task emergencyStop() {
	clearTimer(T3);
	while (SensorValue[redButton] != 1 && time1[T3] < 99000) { wait1Msec(20); }
	stopAllTasks();
}

task main()
{
	datalogClear();
	initConfig(RANTANPLAN);
  initPosition(true);
  while (SensorValue[redButton] == 1) { wait1Msec(20); }
  wait1Msec(500);
 	startTask(displayPos);
  startTask(avoidObstacles);
  startTask(emergencyStop);

  //stratégie simple
  moveTo_forward(1400, 0);//(1200, 0);
  rotateTo(-90);// à cause du maque d'espace
  moveTo_forward(1400,-250);
  rotateTo(-200);//  à cause du maque d'espace
  moveTo_forward(250,200);

  //Ajout pour la recuperation du reste de palet laissé en rade

  //Partie ajouter pour le recuperer le palet rouge
  //moveTo_backward(1400, -50);
  moveTo_backward(600, 50);
  rotateTo(-110)
  moveTo_forward(500, 500);
  rotateTo(180)
  moveTo_forward(400, 500);

  ///////////////////////

    //Partie ajouter pour le retour avec forward

  moveTo_backward(600, 500);
  rotateTo(-200);// à cause du maque d'espace
  moveTo_forward(1200, 500);
  ///////////////////////

  //rotateTo(90)
  moveTo_forward(1200,-350);
  rotateTo(-200)
  moveTo_forward(400,-200);
  moveTo_forward(250,50);

  while (getMovementState() != NOMVT) { wait1Msec(20); }
}
